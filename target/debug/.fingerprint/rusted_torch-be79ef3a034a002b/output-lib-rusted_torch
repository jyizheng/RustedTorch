{"$message_type":"diagnostic","message":"module has the same name as its containing module","code":{"code":"clippy::module_inception","explanation":null},"level":"warning","spans":[{"file_name":"src/tensor/options.rs","byte_start":1304,"byte_end":1898,"line_start":64,"line_end":86,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod options {","highlight_start":1,"highlight_end":18},{"text":"    use super::*;","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn device(device_type: DeviceType, index: i8) -> Options {","highlight_start":1,"highlight_end":67},{"text":"        Options::new().device(Device::new(device_type, index))","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn device_from(device: Device) -> Options {","highlight_start":1,"highlight_end":52},{"text":"        Options::new().device(device)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn dtype(dtype: DType) -> Options {","highlight_start":1,"highlight_end":44},{"text":"        Options::new().dtype(dtype)","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn requires_grad(requires_grad: bool) -> Options {","highlight_start":1,"highlight_end":59},{"text":"        Options::new().requires_grad(requires_grad)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn pinned_memory(pinned_memory: bool) -> Options {","highlight_start":1,"highlight_end":59},{"text":"        Options::new().pinned_memory(pinned_memory)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::module_inception)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: module has the same name as its containing module\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tensor/options.rs:64:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod options {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use super::*;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn device(device_type: DeviceType, index: i8) -> Options {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::module_inception)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"method `clone` can be confused for the standard trait method `std::clone::Clone::clone`","code":{"code":"clippy::should_implement_trait","explanation":null},"level":"warning","spans":[{"file_name":"src/tensor/storage.rs","byte_start":2444,"byte_end":2772,"line_start":94,"line_end":104,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    pub fn clone(&self) -> Result<Self, String> {","highlight_start":5,"highlight_end":50},{"text":"        let new_storage = Self::new(self.size, self.device)?;","highlight_start":1,"highlight_end":62},{"text":"        unsafe {","highlight_start":1,"highlight_end":17},{"text":"            std::ptr::copy_nonoverlapping(","highlight_start":1,"highlight_end":43},{"text":"                self.data.as_ptr(),","highlight_start":1,"highlight_end":36},{"text":"                new_storage.data.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                self.size,","highlight_start":1,"highlight_end":27},{"text":"            );","highlight_start":1,"highlight_end":15},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Ok(new_storage)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::should_implement_trait)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tensor/storage.rs:94:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn clone(&self) -> Result<Self, String> {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let new_storage = Self::new(self.size, self.device)?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        unsafe {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            std::ptr::copy_nonoverlapping(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(new_storage)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::should_implement_trait)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this `impl` can be derived","code":{"code":"clippy::derivable_impls","explanation":null},"level":"warning","spans":[{"file_name":"src/tensor/tensor_impl.rs","byte_start":9398,"byte_end":9705,"line_start":331,"line_end":343,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"impl Default for TensorImpl {","highlight_start":1,"highlight_end":30},{"text":"    fn default() -> Self {","highlight_start":1,"highlight_end":27},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            shape: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            strides: Vec::new(),","highlight_start":1,"highlight_end":33},{"text":"            numel: 0,","highlight_start":1,"highlight_end":22},{"text":"            storage_offset: 0,","highlight_start":1,"highlight_end":31},{"text":"            options: Options::default(),","highlight_start":1,"highlight_end":41},{"text":"            storage: None,","highlight_start":1,"highlight_end":27},{"text":"            autograd_meta: None,","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::derivable_impls)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"replace the manual implementation with a derive attribute","code":null,"level":"help","spans":[{"file_name":"src/tensor/tensor_impl.rs","byte_start":9398,"byte_end":9706,"line_start":331,"line_end":343,"column_start":1,"column_end":3,"is_primary":true,"text":[{"text":"impl Default for TensorImpl {","highlight_start":1,"highlight_end":30},{"text":"    fn default() -> Self {","highlight_start":1,"highlight_end":27},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            shape: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            strides: Vec::new(),","highlight_start":1,"highlight_end":33},{"text":"            numel: 0,","highlight_start":1,"highlight_end":22},{"text":"            storage_offset: 0,","highlight_start":1,"highlight_end":31},{"text":"            options: Options::default(),","highlight_start":1,"highlight_end":41},{"text":"            storage: None,","highlight_start":1,"highlight_end":27},{"text":"            autograd_meta: None,","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/tensor/tensor_impl.rs","byte_start":244,"byte_end":244,"line_start":10,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct TensorImpl {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Default)]\n","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `impl` can be derived\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tensor/tensor_impl.rs:331:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Default for TensorImpl {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m332\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn default() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m334\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            shape: Vec::new(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m343\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::derivable_impls)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: replace the manual implementation with a derive attribute\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ #[derive(Default)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0mpub struct TensorImpl {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module has the same name as its containing module","code":{"code":"clippy::module_inception","explanation":null},"level":"warning","spans":[{"file_name":"src/tensor/mod.rs","byte_start":102,"byte_end":117,"line_start":7,"line_end":7,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub mod tensor;","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: module has the same name as its containing module\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tensor/mod.rs:7:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod tensor;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"method `clone` can be confused for the standard trait method `std::clone::Clone::clone`","code":{"code":"clippy::should_implement_trait","explanation":null},"level":"warning","spans":[{"file_name":"src/tensor/tensor.rs","byte_start":9407,"byte_end":10102,"line_start":301,"line_end":319,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    pub fn clone(&self) -> Self {","highlight_start":5,"highlight_end":34},{"text":"        if let Some(ref impl_) = self.impl_ {","highlight_start":1,"highlight_end":46},{"text":"            if let Some(storage) = impl_.storage() {","highlight_start":1,"highlight_end":53},{"text":"                if let Ok(cloned_storage) = storage.as_ref().clone() {","highlight_start":1,"highlight_end":71},{"text":"                    if let Ok(new_impl) = TensorImpl::new_with_storage(","highlight_start":1,"highlight_end":72},{"text":"                        impl_.shape(),","highlight_start":1,"highlight_end":39},{"text":"                        impl_.options().clone(),","highlight_start":1,"highlight_end":49},{"text":"                        Rc::new(cloned_storage),","highlight_start":1,"highlight_end":49},{"text":"                        impl_.storage_offset(),","highlight_start":1,"highlight_end":48},{"text":"                    ) {","highlight_start":1,"highlight_end":24},{"text":"                        return Self {","highlight_start":1,"highlight_end":38},{"text":"                            impl_: Some(Rc::new(new_impl)),","highlight_start":1,"highlight_end":60},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Self::new()","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tensor/tensor.rs:301:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m301\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn clone(&self) -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if let Some(ref impl_) = self.impl_ {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if let Some(storage) = impl_.storage() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Ok(cloned_storage) = storage.as_ref().clone() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m318\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self::new()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m319\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"deref on an immutable reference","code":{"code":"clippy::borrow_deref_ref","explanation":null},"level":"warning","spans":[{"file_name":"src/autograd/function.rs","byte_start":891,"byte_end":904,"line_start":36,"line_end":36,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"                &*grad_output * &inputs[1],","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#borrow_deref_ref","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::borrow_deref_ref)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if you would like to reborrow, try removing `&*`","code":null,"level":"help","spans":[{"file_name":"src/autograd/function.rs","byte_start":891,"byte_end":904,"line_start":36,"line_end":36,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"                &*grad_output * &inputs[1],","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":"grad_output","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: deref on an immutable reference\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/autograd/function.rs:36:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &*grad_output * &inputs[1],\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if you would like to reborrow, try removing `&*`: `grad_output`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#borrow_deref_ref\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::borrow_deref_ref)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"deref on an immutable reference","code":{"code":"clippy::borrow_deref_ref","explanation":null},"level":"warning","spans":[{"file_name":"src/autograd/function.rs","byte_start":935,"byte_end":948,"line_start":37,"line_end":37,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"                &*grad_output * &inputs[0],","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#borrow_deref_ref","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if you would like to reborrow, try removing `&*`","code":null,"level":"help","spans":[{"file_name":"src/autograd/function.rs","byte_start":935,"byte_end":948,"line_start":37,"line_end":37,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"                &*grad_output * &inputs[0],","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":"grad_output","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: deref on an immutable reference\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/autograd/function.rs:37:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &*grad_output * &inputs[0],\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if you would like to reborrow, try removing `&*`: `grad_output`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#borrow_deref_ref\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module has the same name as its containing module","code":{"code":"clippy::module_inception","explanation":null},"level":"warning","spans":[{"file_name":"src/autograd/function.rs","byte_start":1169,"byte_end":10481,"line_start":51,"line_end":332,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod function {","highlight_start":1,"highlight_end":19},{"text":"    use super::*;","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn add(a: &Tensor, b: &Tensor, _alpha: f32) -> Tensor {","highlight_start":1,"highlight_end":64},{"text":"        a + b","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sub(a: &Tensor, b: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":51},{"text":"        if !a.defined() || !b.defined() {","highlight_start":1,"highlight_end":42},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let a_data = a.to_list::<f32>();","highlight_start":1,"highlight_end":41},{"text":"        let b_data = b.to_list::<f32>();","highlight_start":1,"highlight_end":41},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let result_data: Vec<f32> = a_data.iter().zip(b_data.iter())","highlight_start":1,"highlight_end":69},{"text":"            .map(|(&x, &y)| x - y)","highlight_start":1,"highlight_end":35},{"text":"            .collect();","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = a.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn mul(a: &Tensor, b: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":51},{"text":"        a * b","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn div(a: &Tensor, b: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":51},{"text":"        if !a.defined() || !b.defined() {","highlight_start":1,"highlight_end":42},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let a_data = a.to_list::<f32>();","highlight_start":1,"highlight_end":41},{"text":"        let b_data = b.to_list::<f32>();","highlight_start":1,"highlight_end":41},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let result_data: Vec<f32> = a_data.iter().zip(b_data.iter())","highlight_start":1,"highlight_end":69},{"text":"            .map(|(&x, &y)| x / y)","highlight_start":1,"highlight_end":35},{"text":"            .collect();","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = a.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sin(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":39},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| val.sin()).collect();","highlight_start":1,"highlight_end":81},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn cos(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":39},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| val.cos()).collect();","highlight_start":1,"highlight_end":81},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn pow(base: &Tensor, exponent: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":61},{"text":"        base.pow(exponent)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sum(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":39},{"text":"        x.sum()","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn relu(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":40},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| val.max(0.0)).collect();","highlight_start":1,"highlight_end":84},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn gelu(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":40},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| {","highlight_start":1,"highlight_end":61},{"text":"            0.5 * val * (1.0 + (val * 0.7978845608 * (1.0 + 0.044715 * val * val)).tanh())","highlight_start":1,"highlight_end":91},{"text":"        }).collect();","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn silu(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":40},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| {","highlight_start":1,"highlight_end":61},{"text":"            val / (1.0 + (-val).exp())","highlight_start":1,"highlight_end":39},{"text":"        }).collect();","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn softmax(x: &Tensor, _dim: i64) -> Tensor {","highlight_start":1,"highlight_end":54},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let max_val = data.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));","highlight_start":1,"highlight_end":77},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let exp_data: Vec<f32> = data.iter().map(|&val| (val - max_val).exp()).collect();","highlight_start":1,"highlight_end":90},{"text":"        let sum_exp: f32 = exp_data.iter().sum();","highlight_start":1,"highlight_end":50},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let result_data: Vec<f32> = exp_data.iter().map(|&val| val / sum_exp).collect();","highlight_start":1,"highlight_end":89},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn log_softmax(x: &Tensor, _dim: i64) -> Tensor {","highlight_start":1,"highlight_end":58},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let max_val = data.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));","highlight_start":1,"highlight_end":77},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let exp_data: Vec<f32> = data.iter().map(|&val| (val - max_val).exp()).collect();","highlight_start":1,"highlight_end":90},{"text":"        let sum_exp: f32 = exp_data.iter().sum();","highlight_start":1,"highlight_end":50},{"text":"        let log_sum_exp = sum_exp.ln();","highlight_start":1,"highlight_end":40},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| val - max_val - log_sum_exp).collect();","highlight_start":1,"highlight_end":99},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn tanh(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":40},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| val.tanh()).collect();","highlight_start":1,"highlight_end":82},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn sigmoid(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":43},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| {","highlight_start":1,"highlight_end":61},{"text":"            1.0 / (1.0 + (-val).exp())","highlight_start":1,"highlight_end":39},{"text":"        }).collect();","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn leaky_relu(x: &Tensor, negative_slope: f32) -> Tensor {","highlight_start":1,"highlight_end":67},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| {","highlight_start":1,"highlight_end":61},{"text":"            if val > 0.0 { val } else { negative_slope * val }","highlight_start":1,"highlight_end":63},{"text":"        }).collect();","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn swish(x: &Tensor) -> Tensor {","highlight_start":1,"highlight_end":41},{"text":"        if !x.defined() {","highlight_start":1,"highlight_end":26},{"text":"            return Tensor::new();","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let data = x.to_list::<f32>();","highlight_start":1,"highlight_end":39},{"text":"        let result_data: Vec<f32> = data.iter().map(|&val| {","highlight_start":1,"highlight_end":61},{"text":"            val / (1.0 + (-val).exp())","highlight_start":1,"highlight_end":39},{"text":"        }).collect();","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let shape = x.shape();","highlight_start":1,"highlight_end":31},{"text":"        let options = crate::tensor::Options::default().dtype(crate::tensor::DType::Float32);","highlight_start":1,"highlight_end":94},{"text":"        match crate::tensor::TensorImpl::new_from_data(&result_data, &shape, options) {","highlight_start":1,"highlight_end":88},{"text":"            Ok(impl_) => Tensor {","highlight_start":1,"highlight_end":34},{"text":"                impl_: Some(std::rc::Rc::new(impl_)),","highlight_start":1,"highlight_end":54},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Err(_) => Tensor::new(),","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: module has the same name as its containing module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/autograd/function.rs:51:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod function {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use super::*;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn add(a: &Tensor, b: &Tensor, _alpha: f32) -> Tensor {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m332\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"float has excessive precision","code":{"code":"clippy::excessive_precision","explanation":null},"level":"warning","spans":[{"file_name":"src/autograd/function.rs","byte_start":5033,"byte_end":5045,"line_start":175,"line_end":175,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"            0.5 * val * (1.0 + (val * 0.7978845608 * (1.0 + 0.044715 * val * val)).tanh())","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::excessive_precision)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider changing the type or truncating it to","code":null,"level":"help","spans":[{"file_name":"src/autograd/function.rs","byte_start":5033,"byte_end":5045,"line_start":175,"line_end":175,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"            0.5 * val * (1.0 + (val * 0.7978845608 * (1.0 + 0.044715 * val * val)).tanh())","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":"0.797_884_6","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: float has excessive precision\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/autograd/function.rs:175:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            0.5 * val * (1.0 + (val * 0.7978845608 * (1.0 + 0.044715 * val * val)).tanh())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::excessive_precision)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider changing the type or truncating it to\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            0.5 * val * (1.0 + (val * \u001b[0m\u001b[0m\u001b[38;5;9m0.7978845608\u001b[0m\u001b[0m * (1.0 + 0.044715 * val * val)).tanh())\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            0.5 * val * (1.0 + (val * \u001b[0m\u001b[0m\u001b[38;5;10m0.797_884_6\u001b[0m\u001b[0m * (1.0 + 0.044715 * val * val)).tanh())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"clamp-like pattern without using clamp function","code":{"code":"clippy::manual_clamp","explanation":null},"level":"warning","spans":[{"file_name":"src/functions/loss.rs","byte_start":3555,"byte_end":3585,"line_start":115,"line_end":115,"column_start":32,"column_end":62,"is_primary":true,"text":[{"text":"            let pred_clamped = pred.max(1e-7).min(1.0 - 1e-7);","highlight_start":32,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"clamp will panic if max < min, min.is_nan(), or max.is_nan()","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"clamp returns NaN if the input is NaN","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::manual_clamp)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"replace with clamp","code":null,"level":"help","spans":[{"file_name":"src/functions/loss.rs","byte_start":3555,"byte_end":3585,"line_start":115,"line_end":115,"column_start":32,"column_end":62,"is_primary":true,"text":[{"text":"            let pred_clamped = pred.max(1e-7).min(1.0 - 1e-7);","highlight_start":32,"highlight_end":62}],"label":null,"suggested_replacement":"pred.clamp(1e-7, 1.0 - 1e-7)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: clamp-like pattern without using clamp function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/functions/loss.rs:115:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let pred_clamped = pred.max(1e-7).min(1.0 - 1e-7);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: replace with clamp: `pred.clamp(1e-7, 1.0 - 1e-7)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: clamp will panic if max < min, min.is_nan(), or max.is_nan()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: clamp returns NaN if the input is NaN\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::manual_clamp)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function has too many arguments (8/7)","code":{"code":"clippy::too_many_arguments","explanation":null},"level":"warning","spans":[{"file_name":"src/functions/conv.rs","byte_start":7178,"byte_end":7409,"line_start":174,"line_end":183,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"pub fn batch_norm2d(","highlight_start":1,"highlight_end":21},{"text":"    input: &Tensor,","highlight_start":1,"highlight_end":20},{"text":"    weight: Option<&Tensor>,","highlight_start":1,"highlight_end":29},{"text":"    bias: Option<&Tensor>,","highlight_start":1,"highlight_end":27},{"text":"    running_mean: Option<&Tensor>,","highlight_start":1,"highlight_end":35},{"text":"    running_var: Option<&Tensor>,","highlight_start":1,"highlight_end":34},{"text":"    training: bool,","highlight_start":1,"highlight_end":20},{"text":"    _momentum: f32,","highlight_start":1,"highlight_end":20},{"text":"    eps: f32,","highlight_start":1,"highlight_end":14},{"text":") -> Tensor {","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::too_many_arguments)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function has too many arguments (8/7)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/functions/conv.rs:174:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn batch_norm2d(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    input: &Tensor,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    weight: Option<&Tensor>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    bias: Option<&Tensor>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    eps: f32,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> Tensor {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|___________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::too_many_arguments)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"length comparison to one","code":{"code":"clippy::len_zero","explanation":null},"level":"warning","spans":[{"file_name":"src/data/dataset.rs","byte_start":1686,"byte_end":1709,"line_start":61,"line_end":61,"column_start":40,"column_end":63,"is_primary":true,"text":[{"text":"        if features_shape.len() < 2 || targets_shape.len() < 1 {","highlight_start":40,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::len_zero)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"using `is_empty` is clearer and more explicit","code":null,"level":"help","spans":[{"file_name":"src/data/dataset.rs","byte_start":1686,"byte_end":1709,"line_start":61,"line_end":61,"column_start":40,"column_end":63,"is_primary":true,"text":[{"text":"        if features_shape.len() < 2 || targets_shape.len() < 1 {","highlight_start":40,"highlight_end":63}],"label":null,"suggested_replacement":"targets_shape.is_empty()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: length comparison to one\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data/dataset.rs:61:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if features_shape.len() < 2 || targets_shape.len() < 1 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: using `is_empty` is clearer and more explicit: `targets_shape.is_empty()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::len_zero)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"12 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 12 warnings emitted\u001b[0m\n\n"}
